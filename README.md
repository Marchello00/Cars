Первое задание:

Структура игровых сущностей такая:
Есть машины (car.h CCar) разных классов (enums.h ECarType), у машин есть некоторые характеристики (base.h CBase),
так же к машинам можно добавлять детали (part.h CPart), у каждой детали тоже есть свой класс, в зависимости от того
какого класса деталь ставится на машину определенного класса улучшение может меняться. Так как детали влияют на
характеристики, которые есть у машин, они наследуются от одного класса (base.h CBase).

Про паттерны:
Машины и детали (CCar и CPart) устроены как фабрики, то есть есть классы CRaceCar, CSuperCar, CSuperPart итд, которые
наследуются от CCar или CPart. Это решение выбрано потому что машины/детали разных классов могут отличаться
реализацией функций подсчета стоимости/улучшения, но по своей сути они одинаковы.
В связи с тем что машины можно улучшать отдельными деталями использован паттерн Builder, точнее существует класс
ICarBuilder, который улучшает машину добавляя к ней разные детали(и в свою очередь тоже является фабрикой).

Второе и третье задания:

В основном вся структура и поведение лежат graphic-lib[-src], есть игрок (машина), поверхности, уровень (содержащий
характеристики поверхностей) и некоторые бонусы (поинты/здоровье).
Игрок может ездить и подбирать бонусы, в зависимости от поверхности изменяется ускорение/максимальная скорость,
некоторые поверхности периодически наносят урон. В данной самой простой рабочей версии цель просто собрать как можно больше
бонусов при этом не сломав машину (на тех самых поверхностях наносящих урон).

Что касается структурных паттернов, были использованы адаптер и декоратор, компановщик я не использовал в связи с
отсутствием какой-либо вложенности классов/структур (за исключением дакоратора, разве что, но о нем позже).

Есть один большой не совсем адаптер (src/helpers-lib/TmxLevel.h), скорее просто класс, умеющий читать и структурировать
карты для игры из xml файлов.
Его код взят из интернета, но он был не один раз сильно доработан и изменен. Например, раньше он не умел работать с
поворотами тайлов, и это приводит к второму уже явному использованию паттерна адаптер. Tiled Map Editor, в котором я
делал карты для игры, сохраняет повороты в виде композиции отражений по горизонтали/вертикали/диагонали, а
SFML, графическая библиотека, используемая мной, умеет задавать для спрайтов (текстур) только повороты на определенный
угол, не отражения (по крайней мере в явном виде, в любом случае какую-то работу между Tiled Map Editor и SFML нужно
провести). Решением проблемы стал именно адаптер, в src/helpers-lib/TmxLevel.h есть класс RotatorAdapter, который
по композиции преобразований вернет угол.

Про декоратор: он был использован для поверхности (src/lib/ground.h). Бывают замедляющие поверхности, скользкие поверхности,
поверхности которые наносят урон и просто обычные поверхности, но некоторые свойства иногда нужно комбинировать (тот же урон),
в связи с этим был применен паттерн декоратор. К слову, по структуре получения параметров (get<имя параметра> схема напоминает
компановщик, пусть и со всего одной веткой).

Из поведенческих паттернов были использованы команда, посетитель, наблюдатель и немного паттерн состояние.
Команда была использована для генерации бонусов на карте(src/graphic-lib/gcommand.h), есть возможность задать, например, для разных уровней (хоть их
пока и нет), разные цепочки событий.
Наблюдатель был реализован больше для будущих планов, хотя уместен и сейчас. Машины (хоть игроки, хоть боты),
"подписываются" на информацию об объектах карты к структуре GLevel, которая знает информацию про все объекты на карте
 (вроде типов поверхностей/стен, мест для появления и тд) и в свою очередь передает машинам информацию об объектах,
 с которыми они непосредственно имеют контакт или которые им могут быть полезны. Это реализовано в src/graphic-lib/glevel.h.

 Посетитель был использован для применения бонусов к машине (игроку), собравшей их. Реализовано это в src/graphic-lib/gbonus.h
 и src/graphic-lib/gracer.h (методы, вызываемые из бонусов). Сделано это для удобства добавления разных типов бонусов,
 поведение которых может сильно отличаться, чтобы не загонять все под один неподходящий интерфейс и не делать кашу из
 интерфейсов. Сейчас нет никаких проблем в добавлении бонусов, которые, например, сделают доступным для игрока деталь для машины
 и вместе с ними бонусов, которые нанесут всем врагам урон. Планируется, что открытие новых деталей в игре будет
 реализованно именно так.